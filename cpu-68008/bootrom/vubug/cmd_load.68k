;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Various monitor commands to do with loading data over serial port
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Load - Load data from host
;
; The load protocol is very simple: it is ASCII based and consists of the
; following components:
;
; - 4-byte load base address (in HEX form)
; - 4-byte length value
; - Data bytes
;
;****************************************
;*                                      *
;* Load is invoked as follows:          *
;*                                      *
;*       l<cr> - load from host with no *
;*               offset                 *
;*       l xxxxxxxx - load with offset xxxxxxxx *
;*                                      *
;****************************************
;
Cmd_Load:
  ; did we receive a <cr>? if so, use an offset of 0
  bsr     getch
  cmp.b   #$0d, d0
  beq     .NoOffset

  ; read the offset in
  lea     getch, a0
  bsr     InHex_Long
  move.l  d0, (_pc)
  bra     .StartLoad

.NoOffset:
  ; set default address
  move.l  #$0, (_pc)

.StartLoad:
  ; this clears the UART B receive buffer
  move.b  #0, (UART_B_Queue+UART_Queue_WritePtr)

  ; write a starting message and <cr>
  lea     .MsgLoadStart, a0
  bsr     writs

  move.b  #$0d, d0
  bsr     writu

  ; we're going to use the host port load routine
  lea     lgch, a0
  bclr    #0, (echo)

.ReadAddress:
  ; try to read the load address
  lea     lgch, a0
  bsr     InHex_Long
  move.l  d0, (Load_BaseAddr)

  lea     .MsgLoadAddr, a0
  bsr     writs
  move.l  (Load_BaseAddr), d0
  bsr     OutHex_Long

  ; acknowledge
  moveq   #'.', d0
  bsr     writu

.ReadLength:
  ; then, try to read the total number of bytes
  lea     lgch, a0
  bsr     InHex_Long
  move.l  d0, (Load_TotalLength)

  lea     .MsgLoadLen, a0
  bsr     writs
  move.l  (Load_TotalLength), d0
  bsr     OutHex_Long

  ; acknowledge
  moveq   #'.', d0
  bsr     writu

.PrepareForRead:
  ; read in a byte at a time
  move.l  (Load_TotalLength), d7
  subq.l  #1, d7

  move.l  (Load_BaseAddr), a1

  lea     lgch, a0

.ReceiveLoop:
  ; receive the byte…
  bsr     InHex_Byte
  move.b  d0, (a1)+

  ; …then acknowledge it
  moveq   #'.', d0
  bsr     writu

  dbf     d7, .ReceiveLoop

.LoadDone:
  ; set the entrypoint address
  move.l  (Load_BaseAddr), (_pc)

  ; set up registers and clear register save area
  moveq   #0, d1

  move.w  #$0, (_sr)
  moveq   #$10, d0
  lea     dr0, a1

.ClearRegLoop:
  move.l  d1, (a1)+
  dbf     d0, .ClearRegLoop

  movea.l a0, a2

  ; set up user stack
  lea     ustck, a0
  move.l  a0, (ar7)

  ; write the user PC
  bsr     crlf

  lea     .MsgUserPC, a0
  bsr     writs

  move.l  (_pc), d0
  bsr     OutHex_Long

  ; send the "load done" message
  lea     .MsgLoadDone, a0
  bsr     writs

  ; clear receive buffers
  move.b  #0, (UART_A_Queue+UART_Queue_WritePtr)
  move.b  #0, (UART_B_Queue+UART_Queue_WritePtr)

  ; re-enable echo flag
  bset    #0, (echo)
  rts


.MsgLoadStart:
  dc.b    lf,cr
  dc.b    "Starting load...", nul

.MsgLoadAddr:
  dc.b    lf,cr
  dc.b    "Load address: $", nul

.MsgLoadLen:
  dc.b    lf, cr
  dc.b    "Load size:    $", nul

.MsgUserPC:
  dc.b    lf,cr
  dc.b    "User PC == ", nul

.MsgLoadDone:
  dc.b    lf,cr
  dc.b    "Load done!", nul
  even
