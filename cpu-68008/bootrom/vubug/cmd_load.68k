;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Various monitor commands to do with loading data over serial port
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Load - Load data from host
;
;****************************************
;*                                      *
;* Load is invoked as follows:          *
;*                                      *
;*       l<cr> - load from host with no *
;*               offset                 *
;*       <ff> - same as l<cr> but used  *
;*              only exiting emulator   *
;*       l xxxxxxxx - load with offset xxxxxxxx *
;*                                      *
;****************************************
;
Cmd_Load:
  ; did we receive a <cr>? if so, use an offset of 0
  bsr     getch
  cmp.b   #$0d, d0
  beq     .NoOffset

  ; read the offset in
  lea     getch, a0
  bsr     InHex_Long
  move.l  d0, (_pc)
  bra     .StartLoad

.NoOffset:
  ; set default address
  move.l  #$0, (_pc)

.StartLoad:
  ; this clears the UART B receive buffer
  move.b  #0, (UART_B_Queue+UART_Queue_WritePtr)

  ; write a starting message and <cr>
  lea     .MsgLoadStart, a0
  bsr     writs

  move.b  #$0d, d0
  bsr     writu

  ; we're going to use the host port load routine
  lea     lgch, a0
.GetS:
  ; read the character and wait to get 'S'
  jsr     (a0)                    ;get S

  cmp.b   #'S', d0
  bne     .GetS

  ; get record type: 1 (record) or 9 (done)
  jsr     (a0)                    ;get 1 or 9

  ; did we get a 9? (done)
  cmp.b   #'9', d0
  beq     .LoadDone

  ; was it 1?
  cmp.b   #'1', d0
  bne     .GetS

  ; get the byte count
  bsr     InHex_Byte                    ;get byte count
  move.l  d0, d1

  ; subtract check byte length
  subq.b  #4, d1

  ; read the address and add offset
  bsr     InHex_Word
  add.l   (_pc), d0
  movea.l d0, a1

.ReceiveByte:
  ; read a byte of data, then write it to memory
  bsr     InHex_Byte
  move.b  d0, (a1)+
  dbf     d1, .ReceiveByte

  ; consume check word and newline
  bsr     InHex_Word

  ; try to fetch another record
  bra     .GetS

.LoadDone:
  ; read byte count
  jsr     (a0)
  jsr     (a0)

  ; get address from end
  bsr     InHex_Word

  ; set the entrypoint address
  add.l   (_pc), d0
  move.l  d0, d1
  move.l  d0, (_pc)

  ; set up registers and clear register save area
  moveq   #0, d1

  move.w  #$0, (_sr)
  moveq   #$10, d0
  lea     dr0, a1

.ClearRegLoop:
  move.l  d1, (a1)+
  dbf     d0, .ClearRegLoop

  movea.l a0, a2

  ; set up user stack
  lea     ustck, a0
  move.l  a0, (ar7)

  ; write the user PC
  lea     .MsgUserPC, a0
  bsr     writs

  move.l  d1, d0
  bsr     OutHex_Long

  ; read four more bytes
  movea.l a2, a0

  rept 4
  jsr   (a0)
  endr

  ; send the "load done" message
  lea     .MsgLoadDone, a0
  bsr     writs

  bset    #0, (echo)
  rts


.MsgLoadStart:
  dc.b    lf,cr
  dc.b    "Starting load...", nul

.MsgUserPC:
  dc.b    lf,cr
  dc.b    "User PC == ", nul

.MsgLoadDone:
  dc.b    lf,cr
  dc.b    "Load done!", nul
  even

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Upload - upload program from terminal port
;
;****************************************
;*                                      *
;* Upload is invoked as follows:        *
;*                                      *
;*       u<cr> - load from terminal     *
;*               with no offset         *
;*       u xxxxxxxx - load with offset xxxxxxxx *
;*                                      *
;****************************************
;
Cmd_Upload:
  bsr     getch                   ;same as above, except that it
        cmp.b   #$0d,d0                 ;uses the terminal port for the
        beq     ulnoof                  ;load.
        lea     getch,a0
        bsr     InHex_Long
        move.l  d0,_pc
        bra     uld1
ulnoof: move.l  #$0,_pc
uld1:
        ; this clears the UART A receive buffer
        ; lea     ibuff,a1
        ; move.w  #$0,head(a1)
        ; move.w  #$ffff,tail(a1)
        ; move.w  #$0,count(a1)
        move.b  #0, (UART_A_Queue+UART_Queue_WritePtr)

        ; lea     lmes,a0
        ; bsr     writs
        ; move.b  #$0d,d0
        ; bsr     writu
        lea     getch,a0
        bclr    #$00,echo

        ; TODO: make this work again
        rts
        ; bra     llp                     ;goes to the load routine above
