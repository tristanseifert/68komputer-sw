;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Various monitor commands to do with loading data over serial port
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Load - Load data from host
;
; The load protocol is very simple: it is ASCII based and consists of the
; following components:
;
; - 4-byte load base address (in HEX form)
; - 4-byte checksum over data
; - 4-byte length value
; - Data bytes
;
; Between each of those chunks, we acknowledge by sending a single dot.
;
;****************************************
;*                                      *
;* Load is invoked as follows:          *
;*                                      *
;*       l<cr> - load from host with no *
;*               offset                 *
;*       l xxxxxxxx - load with offset xxxxxxxx *
;*                                      *
;****************************************
;
Cmd_Load:
  ; did we receive a <cr>? if so, use an offset of 0
  bsr     getch
  cmp.b   #$0d, d0
  beq     .NoOffset

  ; read the offset in
  lea     getch, a0
  bsr     InHex_Long
  move.l  d0, (_pc)
  bra     .StartLoad

.NoOffset:
  ; set default address
  move.l  #$0, (_pc)

.StartLoad:
  ; this clears the UART B receive buffer
  move.b  #0, (UART_B_Queue+UART_Queue_WritePtr)

  ; disable echo
  bsr     Echo_Off

  ; write a starting message and <cr>
  lea     .MsgLoadStart, a0
  bsr     writs

  move.b  #$0d, d0
  bsr     writu

  ; we're going to use the host port load routine
  lea     lgch, a0

.ReadAddress:
  ; try to read the load address
  lea     lgch, a0
  bsr     InHex_Long
  move.l  d0, (Load_BaseAddr)

  lea     .MsgLoadAddr, a0
  bsr     writs
  move.l  (Load_BaseAddr), d0
  bsr     OutHex_Long

  ; acknowledge
  moveq   #'.', d0
  bsr     writu

.ReadChecksum:
  ; try to read the load checksum
  lea     lgch, a0
  bsr     InHex_Long
  move.l  d0, (Load_ReceivedChecksum)

  lea     .MsgLoadCheck, a0
  bsr     writs
  move.l  (Load_ReceivedChecksum), d0
  bsr     OutHex_Long

  ; acknowledge
  moveq   #'.', d0
  bsr     writu

.ReadLength:
  ; then, try to read the total number of bytes
  lea     lgch, a0
  bsr     InHex_Long
  move.l  d0, (Load_TotalLength)

  lea     .MsgLoadLen, a0
  bsr     writs
  move.l  (Load_TotalLength), d0
  bsr     OutHex_Long

  ; Print the "Remaining bytes" message
  lea     .MsgLoadRemaining, a0
  bsr     writs
  move.l  (Load_TotalLength), d0
  bsr     OutHex_Long

  ; acknowledge
  moveq   #'.', d0
  bsr     writu

.PrepareForRead:
  ; prepare a "checksum" reg and a temp reg
  moveq   #0, d6
  moveq   #0, d5

  ; read in a byte at a time
  move.l  (Load_TotalLength), d7
  subq.l  #1, d7

  move.l  (Load_BaseAddr), a1

  lea     lgch, a0
  move.l  a0, a2

.ReceiveLoop:
  ; receive the byte…
  bsr     InHex_Byte
  move.b  d0, (a1)+

  move.b  d0, d5
  add.l   d5, d6

  ; update remaining bytes counter
  lea     .MsgBackspace8, a0
  bsr     writs
  move.l  d7, d0
  bsr     OutHex_Long

  move.l  a2, a0

  ; …then acknowledge it
  moveq   #'.', d0
  bsr     writu

  dbf     d7, .ReceiveLoop

.LoadDone:
  ; save our computed checksum and print it out
  move.l  d6, (Load_LocalChecksum)

  lea     .MsgLocalChecksum, a0
  bsr     writs
  move.l  d6, d0
  bsr     OutHex_Long

  ; compare the checksums
  cmp.l   (Load_ReceivedChecksum), d6
  beq     .ChecksumValid

.ChecksumError:
  lea     .MsgChecksumFailed, a0
  bsr     writs
  bra     .Exit

.ChecksumValid:
  ; set the entrypoint address
  move.l  (Load_BaseAddr), (_pc)

  ; set up registers and clear register save area
  moveq   #0, d1

  move.w  #$0, (_sr)
  moveq   #$10, d0
  lea     dr0, a1

.ClearRegLoop:
  move.l  d1, (a1)+
  dbf     d0, .ClearRegLoop

  movea.l a0, a2

  ; set up user stack
  lea     ustck, a0
  move.l  a0, (ar7)

  ; write the user PC
  bsr     crlf

  lea     .MsgUserPC, a0
  bsr     writs

  move.l  (_pc), d0
  bsr     OutHex_Long

  ; send the "load done" message
  lea     .MsgLoadDone, a0
  bsr     writs

.Exit:
  ; clear receive buffers
  move.b  #0, (UART_A_Queue+UART_Queue_WritePtr)
  move.b  #0, (UART_B_Queue+UART_Queue_WritePtr)

  ; re-enable echo flag
  bsr     Echo_On
  rts


.MsgLoadStart:
  dc.b    lf,cr
  dc.b    "Waiting for load...", nul

.MsgLoadAddr:
  dc.b    lf,cr
  dc.b    "Load address:  $", nul

.MsgLoadCheck:
  dc.b    lf, cr
  dc.b    "Load Checksum: $", nul

.MsgLoadLen:
  dc.b    lf, cr
  dc.b    "Load size:     $", nul

.MsgLoadRemaining:
  dc.b    lf, cr
  dc.b    "Remaining      $", nul

.MsgBackspace8:
  dc.b    $1b, "[8D", nul

.MsgLocalChecksum:
  dc.b    lf, cr
  dc.b    "Our Checksum:  $", nul

.MsgChecksumFailed:
  dc.b    lf, lf, cr
  dc.b    $7
  dc.b    "Checksum verification failed!", nul

.MsgUserPC:
  dc.b    lf,cr
  dc.b    "User PC == ", nul

.MsgLoadDone:
  dc.b    lf,cr
  dc.b    "Load done!", nul
  even
