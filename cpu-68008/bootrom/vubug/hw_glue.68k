;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Specific glue to make VUBUG work on the 68komputer hardware.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This is our custom version of the 68681 ISR. This handles the queue driven
; receive/transmit.
VUBUG_MC68681_ISR:
  ; save regs
  move.l  d0, -(sp)

  ; read ISR state
  move.b  (MC68681_Base+MC68681_R_ISR), d0

  ; channel A break?
  btst    #2, d0
  beq.s   .checkChannelBRx

  ; acknowledge interrupt ("reset break irq flag" command to channel A)
  move.b  #%01010000, (MC68681_Base+MC68681_W_CRA)

  ; TODO: jump back to command prompt
  nop

.checkChannelBRx:
  ; channel B receive?
  btst    #5, d0
  beq     .checkChannelARx

  ; read from this channel
  bsr     VUBUG_MC68681_ISR_ChB_Rx

.checkChannelARx:
  ; channel A receive?
  btst    #1, d0
  beq     .checksDone

  ; read from this channel
  bsr     VUBUG_MC68681_ISR_ChA_Rx

.checksDone:

  ; done, clean up
.done:
  move.l  (sp)+, d0
  rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Reads the data from the Channel A register and adds it to the receive queue
VUBUG_MC68681_ISR_ChA_Rx:
  ; read byte
  move.b  (MC68681_Base+MC68681_R_RHRA), d0
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Reads the data from the Channel B register and adds it to the receive queue
VUBUG_MC68681_ISR_ChB_Rx:
  ; read byte
  move.b  (MC68681_Base+MC68681_R_RHRB), d0

  ; just add it to the queue as is. nothing fancy to do for channel B
  rts



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Getch - get a character from the input
; queue. If none available then wait for it (reads from TTY/UART A)
;
; Char is returned to d0
;
getch:
  movem.l #$2060,-(a7)            ;same as lgch above d2,a1,a2

.tryAgain:
  ori.w   #$0700,sr

  ; get input buffer and check if we have a byte
  lea     ibuff,a1
  move.w  count(a1),t1
  beq     .waitForByte

  ; yay, we have data. finaggle the queue to get at it
  moveq   #$0,d0
  movea.w head(a1),d2
  ror.w   #$08,d2
  andi.w  #$00ff,d2

  ; decrement one from the queue
  addq.b  #$1,head(a1)
  subq.b  #$1,count(a1)
  andi.b  #$0f,head(a1)

  ; read out the byte of data :)
  lea     queue(a1),a1
  move.b  $0(a1,d2.w),d0

  andi.w  #$f8ff,sr
  movem.l (a7)+,#$0604            ;regs d2,a1,a2
  rts

; waits for a byte
.waitForByte:
  stop    #$2000
  bra     .tryAgain

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Lgch - get a character from the serial port
; queue. If none available then wait for one (reads from serial/UART B)
;
; Char is returned to d0
;
lgch:   movem.l #$2060,-(a7)            ;save registers d2,a1,a2
lagn:   ori.w   #$0700,sr               ;diable interrupts
        lea     lbuff,a1                ;point at buffer
        move.w  count(a1),t1            ;see if there is a cahracter
        beq     lwait                   ;No, so wait
        move.w  head(a1),d2             ;Yes, find it and update
        ror.w   #$08,d2
        andi.w  #$00ff,d2
        addq.b  #$1,head(a1)
        subq.b  #$1,count(a1)
        andi.b  #$0f,head(a1)
        lea     queue(a1),a1            ;Return character
        move.b  $0(a1,d2.w),d0
        andi.w  #$f8ff,sr               ;enable interrupts and
        movem.l (a7)+,#$0604            ;regs d2,a1/a2
        rts
lwait:  stop    #$2000
        bra     lagn
