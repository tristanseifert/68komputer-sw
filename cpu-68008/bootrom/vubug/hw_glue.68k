;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Specific glue to make VUBUG work on the 68komputer hardware.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This is our custom version of the 68681 ISR. This handles the queue driven
; receive/transmit.
VUBUG_MC68681_ISR:
  ; save regs
  movem.l d0-d1, -(sp)

  ; read ISR state
  move.b  (MC68681_Base+MC68681_R_ISR), d0

  ; channel A break?
  btst    #2, d0
  beq.s   .checkChannelBRx

  ; acknowledge interrupt ("reset break irq flag" command to channel A)
  move.b  #%01010000, (MC68681_Base+MC68681_W_CRA)

  ; TODO: jump back to command prompt
  nop

.checkChannelBRx:
  ; channel B receive?
  btst    #5, d0
  beq     .checkChannelARx

  ; read from this channel
  bsr     VUBUG_MC68681_ISR_ChB_Rx

.checkChannelARx:
  ; channel A receive?
  btst    #1, d0
  beq     .checksDone

  ; read from this channel
  bsr     VUBUG_MC68681_ISR_ChA_Rx

.checksDone:

  ; done, clean up
.done:
  movem.l (sp)+, d0-d1
  rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Reads the data from the Channel A register and adds it to the receive queue
VUBUG_MC68681_ISR_ChA_Rx:
  ; read byte
  move.b  (MC68681_Base+MC68681_R_RHRA), d0

  ; did we receive a Ctrl+C?
  cmp.b   #$03, d0
  beq     .CtrlC
  ; did we receive Ctrl+S?
  cmp.b   #$13, d0
  beq     .CtrlS
  ; did we receive Ctrl+Q?
  cmp.b   #$11, d0
  beq     .CtrlQ

  ; if we get here, we should stuff the received byte into the queue
  lea     (UART_A_Queue), a0
  bsr     VUBUG_MC68681_ISR_Push

  ; is echo turned on?
  btst    #0, echo
  beq.s   .Done

  bra     writ

.Done:
  rts

; Handle Ctrl+S: we set a flag and terminat
.CtrlS:
  move.b  #$1, ctrls
  bra     .Done
; Handle Ctrl+Q: clear the control flag and exit
.CtrlQ:
  move.b  #$00, ctrls
  bra     .Done

; Handle Ctrl+C: (should return to prompt)
.CtrlC:
  ; jump into the restart routine
  bra     VUBUG_Restart

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Reads the data from the Channel B register and adds it to the receive queue
VUBUG_MC68681_ISR_ChB_Rx:
  ; read byte
  move.b  (MC68681_Base+MC68681_R_RHRB), d0

  ; add the byte to the queue
  lea     (UART_B_Queue), a0
  bra     VUBUG_MC68681_ISR_Push

.Done:
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pushes the byte character in d0 into the queue whose header is in a0.
;
; TODO: The carry flag is set if the queue did not have space available.
;
; Clobbers:
;   d0, a0, d1
VUBUG_MC68681_ISR_Push:
  ; is there space in the queue?
  moveq   #0, d1
  move.b  UART_Queue_WritePtr(a0), d1

  cmp.b   #(UART_Queue_DataLen-1), d1
  blt     .QueueFull

  ; yep, write it to where the write pointer says
  move.b  d0, UART_Queue_Data(a0, d1)

  ; increment write pointer
  addq.b  #1, UART_Queue_WritePtr(a0)

  ; we pushed the byte, clear carry flag
  rts

; the queue is full :(
.QueueFull:
  rts



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Getch - get a character from the input
; queue. If none available then wait for it (reads from TTY/UART A)
;
; Char is returned to d0
;
getch:
  ; save registers and set up the queue
  movem.l d1/a1, -(sp)
  lea     (UART_A_Queue), a1

  ; actually read the char
  bsr     VUBUG_MC68681_Getch

  ; clean up (restore registers)
  movem.l (sp)+, d1/a1
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Lgch - get a character from the serial port
; queue. If none available then wait for one (reads from serial/UART B)
;
; Char is returned to d0
;
lgch:
  ; save registers and set up the queue
  movem.l d1/a1, -(sp)
  lea     (UART_B_Queue), a1

  ; actually read the char
  bsr     VUBUG_MC68681_Getch

  ; clean up (restore registers)
  movem.l (sp)+, d1/a1
  rts



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generic routine to pop a character off the queue in a1. Output is in d0, waits
; until data is available
;
; CLOBBERS:
;   d0, d1, a1
VUBUG_MC68681_Getch:
  ; nothing to do here hehe

.tryAgain:
  ; ensure interrupts are disabled while we check these fields
  ori.w   #$0700, sr

  ; is there a byte waiting in the buffer?
  tst.b   UART_Queue_WritePtr(a1)
  beq     .waitForByte

  ; read the byte at the head and decrement write ptr
  subq.b  #1, UART_Queue_WritePtr(a1)

  lea     UART_Queue_Data(a1), a1
  move.b  0(a1), d0

  ; move queue (we copy all but the last byte)
  moveq   #(UART_Queue_DataLen-2), d1

.CopyLoop:
  move.b  1(a1), (a1)
  addq    #1, a1 ; XXX: can we use postincrement?
  dbf     d1, .CopyLoop

  ; we're done!
  andi.w  #$f8ff, sr
  rts

; waits for a byte to be received: really, this waits for an interrupt before
; trying again but whatever man
.waitForByte:
  ; this will re-enable interrupts implicitly
  stop    #$2000
  bra     .tryAgain
