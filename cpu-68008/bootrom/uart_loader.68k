;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; UART code loader
;
; This implements the super basic code loading protocol over UART B. This
; protocol works as follows:
;
; 1. We send a start sequence ($04, $20, $69, $00) on the UART.
; 2. Wait for the sender to respond with the same sequence.
; 3. Sender sends four bytes containing the length of the data, as well as four
;    bytes indicating where to place the data in memory.
; 4. If we can satisfy this request, we respond with $01; if not, we send $00
;    and the transaction should be aborted.
;
; At this point, the sender will send a two byte length value, a two byte
; checksum, and however many bytes specified. At present, the maximum block
; size supported is 256 bytes. Each block is followed up with an acknowledge by
; the receiving side, in the form of a $01 byte. If $00 is sent instead, the
; block should be re-sent.
;
; The end of the transfer is indicated if the high bit in the length field is
; set. The sender will then send 4 byte checksum over all transmitted data,
; while we calculate that over the data we received and compare: if the checksum
; matched, we send $01, $00 otherwise.
;
; After this last byte has been sent, the session is over and user action would
; be required to restart the sequence.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Load size (4 bytes)
UartLoader_LoadSz           = (UartLoader_Base)
; Load address (4 bytes)
UartLoader_LoadAddr         = (UartLoader_LoadSz + $4)
; Address to write the block (4 bytes)
UartLoader_CurrentAddr      = (UartLoader_LoadAddr + $4)
; 4 byte area to hold block length and checksum during reception
UartLoader_BlockHeader      = (UartLoader_CurrentAddr + $4)
UartLoader_BlockHeader_Sz   = (UartLoader_BlockHeader)
UartLoader_BlockHeader_Chk  = (UartLoader_BlockHeader_Sz + $2)
; 4 byte area to hold received handshake
UartLoader_RecvHandshake    = (UartLoader_CurrentAddr + $4)
; 4 byte area to hold received checksum
UartLoader_RecvChecksum     = (UartLoader_RecvHandshake + $4)
; Computed received data checksum (4 bytes)
UartLoader_TotalChecksum    = (UartLoader_RecvChecksum + $4)
; 4 byte total number of received (will always be â‰¤ UartLoader_LoadSz)
UartLoader_TotalBytes       = (UartLoader_TotalChecksum + $4)
; 8 byte string buffer
UartLoader_StrBuf           = (UartLoader_TotalBytes + $4)
; Last block flag (1 byte)
UartLoader_IsLastBlock      = (UartLoader_StrBuf + $8)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Starts the UART loading process, with interactive display on the UART A.
;
UartLoader_Start:
  bsr.w   UartLoader_Reset

  ; display handshake start message
  lea     UartLoader_MsgStart, a0
  bsr.w   UartLoader_DispMessage

  ; send handshake data
  move.l  #$00040001, d0
  lea     UartLoader_Handshake, a0
  bsr.w   MC68681_UartTx

  ; wait to receive handshake data
  lea     UartLoader_RecvHandshake, a0
  move.l  #$00040001, d0
  bsr.w   MC68681_UartRx
  ; was there an error/status flag?
  move.l  d0, d1
  swap    d1
  tst.w   d1
  bne.w   UartLoader_RxError
  ; did we receive 4 bytes?
  cmp.w   #4, d0
  bne.w   UartLoader_RxError_InvalidLength

  ; compare the received handshake
  lea     UartLoader_RecvHandshake, a0
  lea     UartLoader_Handshake, a1

  move.l  (a0), d0
  cmp.l   (a1), d0
  bne.w   UartLoader_InvalidHandshake


  ; receive size
  lea     UartLoader_LoadSz, a0
  move.l  #$00040001, d0
  bsr.w   MC68681_UartRx
  ; was there an error/status flag?
  move.l  d0, d1
  swap    d1
  tst.w   d1
  bne.w   UartLoader_RxError
  ; did we receive 4 bytes?
  cmp.w   #4, d0
  bne.w   UartLoader_RxError_InvalidLength

  ; receive memory location
  lea     UartLoader_LoadAddr, a0
  move.l  #$00040001, d0
  bsr.w   MC68681_UartRx
  ; was there an error/status flag?
  move.l  d0, d1
  swap    d1
  tst.w   d1
  bne.w   UartLoader_RxError
  ; did we receive 4 bytes?
  cmp.w   #4, d0
  bne.w   UartLoader_RxError_InvalidLength

  ; print both the size and location
  bsr.w   UartLoader_PrintLoadInfo

  ; size must be less than $70000
  cmp.l   #$00070000, (UartLoader_LoadSz)
  bcs.w   UartLoader_InvalidLoad

  ; address MUST be $88000
  cmp.l   #$00088000, (UartLoader_LoadAddr)
  bne.w   UartLoader_InvalidLoad

  ; display transfer start and send success byte
  lea     UartLoader_MsgTransferStart, a0
  bsr.w   UartLoader_DispMessage

  move.l  #$00010001, d0
  lea     UartLoader_Success, a0
  bsr.w   MC68681_UartTx

  ; enter the receiving loop
  bsr.s   UartLoader_Receive
  ; once returned, receive and validate
  bsr.s   UartLoader_ValidateChecksum

  ; return back to whoever called us, i guess
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; main receiving loop
UartLoader_Receive:
  ; receive the header of the packet
  lea     UartLoader_BlockHeader, a0
  move.l  #$00040001, d0
  bsr.w   MC68681_UartRx
  ; was there an error/status flag?
  move.l  d0, d1
  swap    d1
  tst.w   d1
  bne.w   UartLoader_RxError
  ; did we receive 4 bytes?
  cmp.w   #4, d0
  bne.w   UartLoader_RxError_InvalidLength

  ; is this the last block?
  btst    #7, (UartLoader_BlockHeader_Sz)
  beq.s   .RegularBlock

  st.b    (UartLoader_IsLastBlock)

.RegularBlock:

  ; continue
  bra.w   UartLoader_Receive

.done:
  ; finished receiving, so exit the loop
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; receives the checksum and validates it
UartLoader_ValidateChecksum:
  ; receive memory location
  lea     UartLoader_RecvChecksum, a0
  move.l  #$00040001, d0
  bsr.w   MC68681_UartRx
  ; was there an error/status flag?
  move.l  d0, d1
  swap    d1
  tst.w   d1
  bne.w   UartLoader_RxError
  ; did we receive 4 bytes?
  cmp.w   #4, d0
  bne.w   UartLoader_RxError_InvalidLength

  ; calculate checksum over the entire received data
  moveq   #0, d0
  move.l  (UartLoader_TotalBytes), d1
  subq.l  #1, d1
  moveq   #0, d2

  move.l  (UartLoader_LoadAddr), a0

.ChecksumLoop:
  ; we read it as a byte to d2, which is cleared to 0, then add that as a long
  move.b  (a0)+, d2
  add.l   d2, d0
  dbf     d1, .ChecksumLoop

  move.l  d0, (UartLoader_TotalChecksum)

  ; Compare checksums
  cmp.l   (UartLoader_RecvChecksum), d2
  bne.s   .InvalidChecksum

  ; finished validation, return
  rts


.InvalidChecksum:
  ; print the received checksum and its value
  lea     UartLoader_MsgRecvChecksum, a0
  bsr.w   UartLoader_DispMessage

  move.l  (UartLoader_RecvChecksum), d0
  lea     UartLoader_StrBuf, a0
  bsr.w   lib_dectohex

  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr.w   MC68681_UartTx

  ; print the calculated checksum and its value
  lea     UartLoader_MsgCalculatedChecksum, a0
  bsr.w   UartLoader_DispMessage

  move.l  (UartLoader_TotalChecksum), d0
  lea     UartLoader_StrBuf, a0
  bsr.w   lib_dectohex

  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr.w   MC68681_UartTx

  ; print a newline
  lea     UartLoader_NewLine, a0
  bsr.w   UartLoader_DispMessage

  ; done
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Prints load information
UartLoader_PrintLoadInfo:
  ; print the load size and its value
  lea     UartLoader_MsgLoadSize, a0
  bsr.w   UartLoader_DispMessage

  move.l  (UartLoader_LoadSz), d0
  lea     UartLoader_StrBuf, a0
  bsr.w   lib_dectohex

  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr.w   MC68681_UartTx

  ; print the load address and its value
  lea     UartLoader_MsgLoadAddr, a0
  bsr.w   UartLoader_DispMessage

  move.l  (UartLoader_LoadAddr), d0
  lea     UartLoader_StrBuf, a0
  bsr.w   lib_dectohex

  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr.w   MC68681_UartTx

  ; print a newline
  lea     UartLoader_NewLine, a0
  bsr.w   UartLoader_DispMessage

  ; done!
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Indicates that the load location/size is invalid.
UartLoader_InvalidLoad:
  ; display the message
  lea     UartLoader_MsgInvalidLoad, a0
  bsr.w   UartLoader_DispMessage

  ; send failure byte
  move.l  #$00010001, d0
  lea     UartLoader_Failure, a0
  bsr.w   MC68681_UartTx

  ; return
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; indicates the handshake is invalid
UartLoader_InvalidHandshake:
  ; convert the received handshake value to a string
  move.l  (a0), d0
  lea     UartLoader_StrBuf, a0
  bsr.w   lib_dectohex

  lea     UartLoader_MsgInvalidHandshake, a0
  bsr.w   UartLoader_SignalFailureWithMsg

  ; print the error code string (8 bytes)
  lea     UartLoader_StrBuf, a0

  moveq   #8, d0
  swap    d0

  bsr.w   MC68681_UartTx

  ; finish it out with a newline
  lea     UartLoader_NewLine, a0
  bra.w   UartLoader_DispMessage
  ; rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Signals failure to the remote end and prints a message (in a0)
UartLoader_SignalFailureWithMsg:
  ; display the message
  bsr.w   UartLoader_DispMessage

  ; send failure byte
  move.l  #$00010001, d0
  lea     UartLoader_Failure, a0
  bsr.w   MC68681_UartTx

  ; return
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Handles an UART invalid bytes error (state in D0)
UartLoader_RxError_InvalidLength:
  ; convert error code to a string
  lea     UartLoader_StrBuf, a0
  bsr.w   lib_dectohex

  ; display the text string
  lea     UartLoader_MsgUartRxErrLength, a0
  bsr.w   UartLoader_DispMessage

  ; jump to the rest below
  bra.s   UartLoader_RxError_Shared


; Handles an UART receive error (state in d0)
UartLoader_RxError:
  ; convert error code to a string
  lea     UartLoader_StrBuf, a0
  bsr.w   lib_dectohex

  ; display the text string
  lea     UartLoader_MsgUartRxErr, a0
  bsr.w   UartLoader_DispMessage

UartLoader_RxError_Shared:
  ; print the error code string (8 bytes)
  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr.w   MC68681_UartTx

  ; finish it out with a newline
  lea     UartLoader_NewLine, a0
  bsr.w   UartLoader_DispMessage

  ; done!
  rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Helper routines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Clears loader state
UartLoader_Reset:
  lea     (UartLoader_Base), a0
  moveq   #0, d0
  moveq   #($200/4)-1, d1

.clear:
  move.l  d0, (a0)+
  dbf     d1, .clear

  rts

; Displays the string in a0 on UART A.
UartLoader_DispMessage:
  move.l  a0, a1
  bsr.w   lib_strlen

  swap    d0
  move.w  #0, d0

  move.l  a1, a0
  bra.w   MC68681_UartTx

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Display strings
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
UartLoader_MsgStart:
  dc.b  "Sending handshake...", $0A, 0
  even
UartLoader_MsgTransferStart:
  dc.b  "Ready to receive data. Status will be output below with one character"
  dc.b  "per", $0A, "received block. (. = OK, * = checksum, E = end)", $0A, 0
  even

UartLoader_MsgInvalidLoad:
  dc.b  "The size of data or load address is not valid on this machine", $0A, 0
  even
UartLoader_MsgInvalidHandshake:
  dc.b  "The received handshake is invalid: $", 0
  even

UartLoader_MsgUartRxErr:
  dc.b  "UART receive error: $", 0
  even
UartLoader_MsgUartRxErrLength:
  dc.b  "UART receive error (invalid length): $", 0
  even

UartLoader_MsgLoadSize:
  dc.b  "   Load size: $", 0
  even
UartLoader_MsgLoadAddr:
  dc.b  $0A, "Load address: $", 0
  even

UartLoader_MsgRecvChecksum:
  dc.b  "  Received checksum: $", 0
  even
UartLoader_MsgCalculatedChecksum:
  dc.b  $0A, "Calculated checksum: $", 0
  even

UartLoader_NewLine:
  dc.b  $0A, 0
  even

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Failure response
UartLoader_Failure:
  dc.b  $00
  even

; Success response
UartLoader_Success:
  dc.b  $01
  even

; This is the handshake value we send, and expect to receive back
UartLoader_Handshake:
  dc.b  $04, $20, $69, $00
  even
