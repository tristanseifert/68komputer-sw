;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; UART code loader
;
; This implements the super basic code loading protocol over UART B. This
; protocol works as follows:
;
; 1. We send a start sequence ($04, $20, $69, $xx) on the UART. The last byte is
;    the log2 of the max block size; e.g. for 256 bytes it would be 8, since 2^8
;    equals 256.
; 2. Wait for the sender to respond with the same sequence.
; 3. Sender sends four bytes containing the length of the data, as well as four
;    bytes indicating where to place the data in memory.
; 4. If we can satisfy this request, we respond with $01; if not, we send $00
;    and the transaction should be aborted.
;
; At this point, the sender will send a two byte length value, a two byte
; checksum, and wait for a $01 ack, or terminate the transfer if $00 is
; received. If acknowledged successfully, start sending data. At present, the
; maximum block size supported is 256 bytes. Each block is followed up with an
; acknowledge by the receiving side, in the form of a $01 byte. If $00 is sent
; instead, the block should be re-sent.
;
; The end of the transfer is indicated if the high bit in the length field is
; set. The sender will then send 4 byte checksum over all transmitted data,
; while we calculate that over the data we received and compare: if the checksum
; matched, we send $01, $00 otherwise.
;
; After this last byte has been sent, the session is over and user action would
; be required to restart the sequence.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Load size (4 bytes)
UartLoader_LoadSz           = (UartLoader_Base)
; Load address (4 bytes)
UartLoader_LoadAddr         = (UartLoader_LoadSz + $4)
; Address to write the block (4 bytes)
UartLoader_CurrentAddr      = (UartLoader_LoadAddr + $4)
; 4 byte area to hold block length and checksum during reception
UartLoader_BlockHeader      = (UartLoader_CurrentAddr + $4)
UartLoader_BlockHeader_Sz   = (UartLoader_BlockHeader)
UartLoader_BlockHeader_Chk  = (UartLoader_BlockHeader_Sz + $2)
; 4 byte area to hold received handshake
UartLoader_RecvHandshake    = (UartLoader_CurrentAddr + $4)
; 4 byte area to hold received checksum
UartLoader_RecvChecksum     = (UartLoader_RecvHandshake + $4)
; Computed received data checksum (4 bytes)
UartLoader_TotalChecksum    = (UartLoader_RecvChecksum + $4)
; 4 byte total number of received (will always be â‰¤ UartLoader_LoadSz)
UartLoader_TotalBytes       = (UartLoader_TotalChecksum + $4)
; 8 byte string buffer
UartLoader_StrBuf           = (UartLoader_TotalBytes + $4)
; Last block flag (1 byte)
UartLoader_IsLastBlock      = (UartLoader_StrBuf + $8)
; result of the last data receive operation (4 bytes; 1 byte alignment before)
UartLoader_LastRxStatus     = (UartLoader_IsLastBlock + $2)
; block number
UartLoader_BlockNumber      = (UartLoader_LastRxStatus + $4)
; 256 byte receive buffer
UartLoader_ReceiveBuffer    = (UartLoader_BlockNumber + $4)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Starts the UART loading process, with interactive display on the UART A.
;
UartLoader_Start:
  bsr     UartLoader_Reset

  ; display handshake start message
  lea     UartLoader_MsgStart, a0
  bsr     UartLoader_DispMessage

  ; send handshake data
  move.l  #$00040001, d0
  lea     UartLoader_Handshake, a0
  bsr     MC68681_UartTx

  ; wait to receive handshake data
  lea     UartLoader_RecvHandshake, a0
  move.l  #$00040001, d0
  bsr     MC68681_UartRx
  ; was there an error/status flag?
  move.l  d0, d1
  swap    d1
  tst.w   d1
  bne     UartLoader_RxError
  ; did we receive 4 bytes?
  cmp.w   #4, d0
  bne     UartLoader_RxError_InvalidLength

  ; compare the received handshake
  lea     UartLoader_RecvHandshake, a0
  lea     UartLoader_Handshake, a1

  move.l  (a0), d0
  cmp.l   (a1), d0
  bne     UartLoader_InvalidHandshake


  ; receive size
  lea     UartLoader_LoadSz, a0
  move.l  #$00040001, d0
  bsr    MC68681_UartRx
  ; was there an error/status flag?
  move.l  d0, d1
  swap    d1
  tst.w   d1
  bne     UartLoader_RxError
  ; did we receive 4 bytes?
  cmp.w   #4, d0
  bne     UartLoader_RxError_InvalidLength

  ; receive memory location
  lea     UartLoader_LoadAddr, a0
  move.l  #$00040001, d0
  bsr     MC68681_UartRx
  ; was there an error/status flag?
  move.l  d0, d1
  swap    d1
  tst.w   d1
  bne     UartLoader_RxError
  ; did we receive 4 bytes?
  cmp.w   #4, d0
  bne     UartLoader_RxError_InvalidLength

  ; print both the size and location
  bsr     UartLoader_PrintLoadInfo

  ; size must be less than $70000
  cmp.l   #$00070000, (UartLoader_LoadSz)
  bcs     UartLoader_InvalidLoad

  ; address MUST be $88000
  cmp.l   #$00088000, (UartLoader_LoadAddr)
  bne     UartLoader_InvalidLoad

  ; display transfer start and send success byte
  lea     UartLoader_MsgTransferStart, a0
  bsr     UartLoader_DispMessage

  bsr     UartLoader_AckSuccess

  ; enter the receiving loop
  bsr     UartLoader_Receive
  ; once returned, receive and validate
  bsr     UartLoader_ValidateChecksum

  ; return back to whoever called us, i guess
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; main receiving loop
UartLoader_Receive:
  ; clear some state
  moveq   #0, d0

  move.b  d0, (UartLoader_IsLastBlock)
  move.l  d0, (UartLoader_BlockNumber)

  ; set up the load address
  move.l  (UartLoader_LoadAddr), (UartLoader_CurrentAddr)

.ReceiveLoop:
  ; receive the header of the packet
  lea     UartLoader_BlockHeader, a0
  move.l  #$00040001, d0
  bsr     MC68681_UartRx
  ; was there an error/status flag?
  move.l  d0, d1
  swap    d1
  tst.w   d1
  bne     UartLoader_RxError
  ; did we receive 4 bytes?
  cmp.w   #4, d0
  bne     UartLoader_RxError_InvalidLength

  ; is this the last block?
  btst    #7, (UartLoader_BlockHeader_Sz)
  beq     .RegularBlock

  ; it is, so set the "last block" flag so the loop terminates
  st.b    (UartLoader_IsLastBlock)

.RegularBlock:
  ; ensure size is less than $100
  cmp.w   #$100, (UartLoader_BlockHeader_Sz)
  bhs     .InvalidSizeOrChecksum

  ; it's good, so send an ack byte
  bsr     UartLoader_AckSuccess

  ; receive that many bytes into our rx buffer
  lea     UartLoader_ReceiveBuffer, a0
  moveq   #0, d0
  move.w  (UartLoader_BlockHeader_Sz), d0
  swap    d0
  or.b    #$01, d0
  bsr     MC68681_UartRx
  ; was there an error/status flag?
  move.l  d0, d1
  swap    d1
  tst.w   d1
  bne     UartLoader_RxError
  ; did we receive any bytes?
  tst.w   d0
  beq     .NoDataReceived

  ; store the state
  move.l  d0, (UartLoader_LastRxStatus)

  ; bet. calculate the checksum over the data (TODO lmaoo)

  ; checksum is good, print a dot and copy data
  lea     UartLoader_BlockOk, a0
  bsr     UartLoader_DispMessage

  moveq   #0, d1
  move.w  (UartLoader_LastRxStatus + $2), d1
  move.l  d1, d0
  subq.l  #1, d0

  lea     UartLoader_ReceiveBuffer, a0
  move.l  (UartLoader_CurrentAddr), a1

.CopyLoop:
  move.b  (a0)+, (a1)+
  dbf     d0, .CopyLoop

  ; increment address and total bytes counter
  ; moveq   #0, d0
  ; move.w  (UartLoader_LastRxStatus + $2), d0
  add.l   d1, (UartLoader_CurrentAddr)
  add.l   d1, (UartLoader_TotalBytes)

  ; increment our counter and acknowledge success
  addq.l  #1, (UartLoader_BlockNumber)
  bsr     UartLoader_AckSuccess

  ; repeat the loop unless this is the last block
  tst.b   (UartLoader_IsLastBlock)
  beq     .ReceiveLoop

.done:
  ; finished receiving, so exit the loop
  lea     UartLoader_BlockEnd, a0
  bsr     UartLoader_DispMessage

  lea     UartLoader_MsgTransferFinished, a0
  bsr     UartLoader_DispMessage

  move.l  (UartLoader_TotalBytes), d0
  lea     UartLoader_StrBuf, a0
  bsr     lib_dectohex

  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr     MC68681_UartTx

  lea     UartLoader_NewLine, a0
  bra     UartLoader_DispMessage

  rts



; we didn't receive any data for some reason
.NoDataReceived:
  lea     UartLoader_MsgNoDataForBlock, a0
  bsr     UartLoader_DispMessage

  move.l  (UartLoader_BlockNumber), d0
  lea     UartLoader_StrBuf, a0
  bsr     lib_dectohex

  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr     MC68681_UartTx

  lea     UartLoader_NewLine, a0
  bra     UartLoader_DispMessage

  ; rts

; handles an invalid size or checksum
.InvalidSizeOrChecksum:
  ; display checksum error message and send a negative ack
  lea     UartLoader_BlockChecksum, a0
  bsr     UartLoader_DispMessage

  bsr     UartLoader_AckFailed

  ; jump back to the start of the loop
  bra     .ReceiveLoop

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; receives the checksum and validates it
UartLoader_ValidateChecksum:
  ; receive memory location
  lea     UartLoader_RecvChecksum, a0
  move.l  #$00040001, d0
  bsr     MC68681_UartRx
  ; was there an error/status flag?
  move.l  d0, d1
  swap    d1
  tst.w   d1
  bne     UartLoader_RxError
  ; did we receive 4 bytes?
  cmp.w   #4, d0
  bne     UartLoader_RxError_InvalidLength

  ; calculate checksum over the entire received data
  moveq   #0, d0
  move.l  (UartLoader_TotalBytes), d1
  subq.l  #1, d1
  moveq   #0, d2

  move.l  (UartLoader_LoadAddr), a0

.ChecksumLoop:
  ; we read it as a byte to d2, which is cleared to 0, then add that as a long
  move.b  (a0)+, d2
  add.l   d2, d0
  dbf     d1, .ChecksumLoop

  move.l  d0, (UartLoader_TotalChecksum)

  ; Compare checksums
  cmp.l   (UartLoader_RecvChecksum), d2
  bne     .InvalidChecksum

  ; finished validation, return
  rts


.InvalidChecksum:
  ; print the received checksum and its value
  lea     UartLoader_MsgRecvChecksum, a0
  bsr     UartLoader_DispMessage

  move.l  (UartLoader_RecvChecksum), d0
  lea     UartLoader_StrBuf, a0
  bsr     lib_dectohex

  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr     MC68681_UartTx

  ; print the calculated checksum and its value
  lea     UartLoader_MsgCalculatedChecksum, a0
  bsr     UartLoader_DispMessage

  move.l  (UartLoader_TotalChecksum), d0
  lea     UartLoader_StrBuf, a0
  bsr     lib_dectohex

  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr     MC68681_UartTx

  ; print a newline
  lea     UartLoader_NewLine, a0
  bsr     UartLoader_DispMessage

  ; done
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Sends an acknowledgement.
UartLoader_AckFailed:
  lea     UartLoader_Failure, a0
  bra     UartLoader_AckShared

UartLoader_AckSuccess:
  lea     UartLoader_Success, a0

UartLoader_AckShared:
  move.l  #$00010001, d0
  bra     MC68681_UartTx

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Prints load information
UartLoader_PrintLoadInfo:
  ; print the load size and its value
  lea     UartLoader_MsgLoadSize, a0
  bsr     UartLoader_DispMessage

  move.l  (UartLoader_LoadSz), d0
  lea     UartLoader_StrBuf, a0
  bsr     lib_dectohex

  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr     MC68681_UartTx

  ; print the load address and its value
  lea     UartLoader_MsgLoadAddr, a0
  bsr     UartLoader_DispMessage

  move.l  (UartLoader_LoadAddr), d0
  lea     UartLoader_StrBuf, a0
  bsr     lib_dectohex

  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr     MC68681_UartTx

  ; print a newline
  lea     UartLoader_NewLine, a0
  bsr     UartLoader_DispMessage

  ; done!
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Indicates that the load location/size is invalid.
UartLoader_InvalidLoad:
  ; display the message
  lea     UartLoader_MsgInvalidLoad, a0
  bsr     UartLoader_DispMessage

  ; send failure byte
  bra     UartLoader_AckFailed

  ; return
  ; rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; indicates the handshake is invalid
UartLoader_InvalidHandshake:
  ; convert the received handshake value to a string
  move.l  (a0), d0
  lea     UartLoader_StrBuf, a0
  bsr     lib_dectohex

  lea     UartLoader_MsgInvalidHandshake, a0
  bsr     UartLoader_SignalFailureWithMsg

  ; print the error code string (8 bytes)
  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr     MC68681_UartTx

  ; finish it out with a newline
  lea     UartLoader_NewLine, a0
  bra     UartLoader_DispMessage
  ; rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Signals failure to the remote end and prints a message (in a0)
UartLoader_SignalFailureWithMsg:
  ; display the message
  bsr     UartLoader_DispMessage

  ; send failure byte
  bra     UartLoader_AckFailed

  ; return
  ; rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Handles an UART invalid bytes error (state in D0)
UartLoader_RxError_InvalidLength:
  ; convert error code to a string
  lea     UartLoader_StrBuf, a0
  bsr     lib_dectohex

  ; display the text string
  lea     UartLoader_MsgUartRxErrLength, a0
  bsr     UartLoader_DispMessage

  ; jump to the rest below
  bra     UartLoader_RxError_Shared


; Handles an UART receive error (state in d0)
UartLoader_RxError:
  ; convert error code to a string
  lea     UartLoader_StrBuf, a0
  bsr     lib_dectohex

  ; display the text string
  lea     UartLoader_MsgUartRxErr, a0
  bsr     UartLoader_DispMessage

UartLoader_RxError_Shared:
  ; print the error code string (8 bytes)
  lea     UartLoader_StrBuf, a0
  moveq   #8, d0
  swap    d0
  bsr     MC68681_UartTx

  ; finish it out with a newline
  lea     UartLoader_NewLine, a0
  bsr     UartLoader_DispMessage

  ; done!
  rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Helper routines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Clears loader state
UartLoader_Reset:
  lea     (UartLoader_Base), a0
  moveq   #0, d0
  moveq   #($200/4)-1, d1

.clear:
  move.l  d0, (a0)+
  dbf     d1, .clear

  rts

; Displays the string in a0 on UART A.
UartLoader_DispMessage:
  move.l  a0, a1
  bsr     lib_strlen

  swap    d0
  move.w  #0, d0

  move.l  a1, a0
  bra     MC68681_UartTx

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Display strings
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
UartLoader_MsgStart:
  dc.b  "Data will be received on UART B via xfer protocol", $0A
  dc.b  "Sending handshake...", $0A, 0
  even
UartLoader_MsgTransferStart:
  dc.b  "Ready to receive data. Status will be output below with one character"
  dc.b  "per", $0A, "received block. (. = OK, * = checksum, E = end)", $0A, 0
  even

UartLoader_MsgInvalidLoad:
  dc.b  "The size of data or load address is not valid on this machine", $0A, 0
  even
UartLoader_MsgInvalidHandshake:
  dc.b  "The received handshake is invalid: $", 0
  even

UartLoader_MsgUartRxErr:
  dc.b  "UART receive error: $", 0
  even
UartLoader_MsgUartRxErrLength:
  dc.b  "UART receive error (invalid length): $", 0
  even

UartLoader_MsgLoadSize:
  dc.b  "   Load size: $", 0
  even
UartLoader_MsgLoadAddr:
  dc.b  $0A, "Load address: $", 0
  even

UartLoader_MsgRecvChecksum:
  dc.b  "  Received checksum: $", 0
  even
UartLoader_MsgCalculatedChecksum:
  dc.b  $0A, "Calculated checksum: $", 0
  even

UartLoader_MsgNoDataForBlock:
  dc.b  $0A, "No data was received for block $", 0
  even

UartLoader_BlockOk:
  dc.b  ".", 0
  even
UartLoader_BlockChecksum:
  dc.b  "*", 0
  even
UartLoader_BlockEnd:
  dc.b  "E", 0
  even

UartLoader_MsgTransferFinished:
  dc.b  $0A, "Received bytes: $", 0
  even

UartLoader_NewLine:
  dc.b  $0A, 0
  even

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Failure response
UartLoader_Failure:
  dc.b  $00
  even

; Success response
UartLoader_Success:
  dc.b  $01
  even

; This is the handshake value we send; last value is log_2 of the max block sz
UartLoader_Handshake:
  dc.b  $04, $20, $69, $08
  even
