;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Loader services
;
; All services return a status code in d0. 0 for success, negative for error.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; List of available services
Svc_Table:
  ; 00: no-op
  dc.w    Svc_NoOp-Svc_Table
  ; 01: write bytes to UART
  dc.w    Svc_UartOut-Svc_Table
  ; 02: read bytes from UART
  dc.w    Svc_UartIn-Svc_Table
  ; 03: Delay program
  dc.w    Svc_Delay-Svc_Table
  ; 04: Get input state
  dc.w    Svc_ReadIO-Svc_Table
  ; 05: Set output state
  dc.w    Svc_WriteIO-Svc_Table
  ; 06: Read RTC
  dc.w    Svc_ReadRtc-Svc_Table
  ; 07: Write RTC
  dc.w    Svc_WriteRtc-Svc_Table
  ; 08: Write character to TTY
  dc.w    Svc_Putc-Svc_Table
  ; 09: Read character from TTY
  dc.w    Svc_Getc-Svc_Table
  ; 0A: Read character from TTY (nonblocking)
  dc.w    Svc_Getc_Nonblocking-Svc_Table
  ; 0B: Write string to TTY
  dc.w    Svc_Puts-Svc_Table
  ; 0C: Write a number as hexadecimal to TTY
  dc.w    Svc_OutHex-Svc_Table
Svc_Table_End:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 00 - Does nothing
;
; INPUTS:
;   None
; OUTPUTS:
;   None
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_NoOp:
  moveq   #0, d0
  rts



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 01 - Writes a byte buffer to the specified UART.
;
; NOTE: This does NOT handle zero-terminated strings by default.
;
; INPUTS:
;   a1: Buffer to read from
;   d1: Number of bytes to write (high word) and UART number (low word)
; OUTPUTS:
;   d0: Error code (negative) or bytes written (> 0)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_UartOut:
  ; back up registers
  move.l  d2, -(sp)

  ; is the UART number in range?
  cmp.w   #2, d1
  bge.s   .UartNumOutOfRange

  ; length should be nonzero
  swap    d1
  tst.w   d1
  beq.s   .InvalidLength
  swap    d1

  ; write to the appropriate UART
  move.l  a1, a0
  move.l  d1, d0
  bsr.w   MC68681_UartTx

.Done:
  ; Restore registers
  move.l  d2, (sp)+

  rts

.UartNumOutOfRange:
  moveq   #-2, d0
  bra.s   .Done
.InvalidLength:
  moveq   #-1, d0
  bra.s   .Done



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 02 - Reads a byte buffer from the specified UART.
;
; INPUTS:
;   a1: Buffer to read data to
;   d1: Number of bytes to read (high word) and UART number (low word)
; OUTPUTS:
;   d0: Error code (negative) or bytes read (> 0)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_UartIn:
  ; back up registers
  movem.l  d2-d3, -(sp)

  ; is the UART number in range?
  cmp.w   #2, d1
  bge.s   .UartNumOutOfRange

  ; length should be nonzero
  swap    d1
  tst.w   d1
  beq.s   .InvalidLength
  swap    d1

  ; read from the appropriate UART
  move.l  a1, a0
  move.l  d1, d0
  bsr.w   MC68681_UartRx

  ; reformat return code d0
  swap    d0
  tst.w   d0
  bne.s   .NoError

  ; there were errors. extract them
  moveq   #0, d2
  swap    d0
  and.w   d2, d0
  swap    d0
  neg.l   d0

  bra.s   .Done

.NoError:
  ; nothing needs to be done, we're good
  nop

.Done:
  ; restore registers
  movem.l  (sp)+, d2-d3
  rts

.UartNumOutOfRange:
  moveq   #-2, d0
  bra.s   .Done
.InvalidLength:
  moveq   #-1, d0
  bra.s   .Done



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 03 - Waits for a certain period of time.
;
; NOTE:
;   This routine requires interrupts to be enabled.
; INPUTS:
;   d1: How long to delay for, in 1/100ths of a second.
; OUTPUTS:
;   None
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_Delay:
  lea     Loader_Tick, a0

  ; calculate the tick value to wait for
  move.l  (a0), d0
  add.l   d1, d0

  ; wait until the values are identical
.wait:
  cmp.l   (a0), d0
  beq     .wait

  rts



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 04 - Reads the input lines on the 68681.
;
; INPUTS:
;   None
; OUTPUTS:
;   d0: State of IO lines: bit 0 is IP0, bit 1 is IP1, and so forth.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_ReadIO:
  ; update state from hardware
  bsr.w   MC68681_UpdateInput

  ; read port state
  move.b  (Loader_68681In), d0
  rts



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 05 - Sets the state of the output lines on the 68681.
;
; INPUTS:
;   d1: Which pins to set low (high word) and which to set high (low word). If
;       the same pin is set to be both low and high, an error is returned.
; OUTPUTS:
;   None
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_WriteIO:
  ; back up registers
  move.l  d2, -(sp)

  ; check that no pins are specified twice
  moveq   #0, d2
  move.w  d1, d2
  swap    d1
  and.w   d1, d2
  bne.s   .Invalid

  ; bits to clear are in the low word of d1, so AND against its inverse
  not.w   d1
  and.b   d1, (Loader_68681Out)

  ; extract bits to set high (high word of d1)
  move.w  d1, d2
  swap    d1
  and.w   #$00FF, d1

  ; we now have the bits to set in the low byte of d1, so OR into memory state
  or.b    d1, (Loader_68681Out)

  ; actually update output
  bsr.w   MC68681_UpdateOutput
  moveq   #0, d0

.Done:
  ; Restore registers
  move.l  (sp)+, d2
  rts

.Invalid:
  moveq   #-1, d0
  bra.s   .Done


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 06 - Reads the RTC and updates the in memory date/time variables.
;
; INPUTS:
;   None
; OUTPUTS:
;   None
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_ReadRtc:
  ; back up registers
  movem.l d0/d2-d3/a1, -(sp)

  bsr.w   RTC_Read

  ; restore registers
  movem.l (sp)+, d0/d2-d3/a1
  moveq   #0, d0

  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 07 - Writes to the RTC the values in the memory date/time variables.
;
; INPUTS:
;   None
; OUTPUTS:
;   None
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_WriteRtc:
  ; back up registers
  movem.l d0/d2-d3/a1, -(sp)

  bsr.w   RTC_Write

  ; restore registers
  movem.l (sp)+, d0/d2-d3/a1
  moveq   #0, d0

  rts



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 08 - Writes a single character to the active TTY.
;
; INPUTS:
;   d1: 8 bit character to write
; OUTPUTS:
;   None
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_Putc:
  ; write character to DUART
  move.b  d1, (MC68681_Base+MC68681_W_THRA)

  ; then, wait for tx to complete
.wait:
  ; read the status register, check TXRDY bit (2), loop while clear
  move.b  (MC68681_Base+MC68681_R_SRA), d0
  btst    #2, d0
  beq     .wait
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 09 - Reads a single character from the active TTY.
;
; NOTE:
;   This call will block until a character arrives. Interrupts must be enabled
;   or the call will deadlock.
; INPUTS:
;   None
; OUTPUTS:
;   d0: Received character
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_Getc:
  lea     (MC68681_Base), a0

.WaitForByte:
	; is there a byte?
	move.b  MC68681_R_SRA(a0), d0
	btst    #0, d0
	beq.s		.WaitForByte

	; read the byte
	move.b	MC68681_R_RHRA(a0), d0

  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 0A - Reads a single character from the active TTY without blocking.
;
; NOTE:
;   Interrupts must be enabled or the call will deadlock.
; INPUTS:
;   None
; OUTPUTS:
;   d0: Received character, or -1 if no character
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_Getc_Nonblocking:
  lea     (MC68681_Base), a0

	; is there a byte?
	move.b  MC68681_R_SRA(a0), d0
	btst    #0, d0
	beq.s		.NoCharacter

	; read the byte
	move.b	MC68681_R_RHRA(a0), d0

  rts

.NoCharacter:
  moveq   #-1, d0
  rts



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 0B - Prints a null-terminated string to the TTY.
;
; INPUTS:
;   a0: String to output
; OUTPUTS:
;   None
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_Puts:
  bra     Out_Puts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 0C - Prints a hexadecimal number to the TTY with a given precision.
;
; INPUTS:
;   d1: Number to output
;   d2: Size of the number (1, 2, or 4)
; OUTPUTS:
;   d0: -1 if an argument was invalid, 0 otherwise.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Svc_OutHex:
  ; 4 bytes?
  cmp.b   #4, d2
  bne     .Check1

  ; yup, so print a long
  move.l  d1, d0
  bsr     OutHex_Long
  bra     .Done

.Check1:
  ; 1 byte?
  cmp.b   #1, d2
  bne     .Check2

  ; yup, so print a byte
  move.l  d1, d0
  bsr     OutHex_Byte
  bra     .Done

.Check2:
  ; 2 bytes?
  cmp.b   #1, d2
  bne     .InvalidSize

  ; yup, so print a word
  move.l  d1, d0
  bsr     OutHex_Word
  bra     .Done

.Done:
  ; done, clear d0
  moveq   #0, d0
  rts



.InvalidSize:
  moveq   #-1, d0
  rts
