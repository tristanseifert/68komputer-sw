;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 68komputer bootloader
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  list
  org   $0

  include "hardware.68k"
  include "ram.68k"
  include "loader_api.68k"

; vector table
VectorTable:
  dc.l  RAM_Stack_Base, EntryPoint

  dc.l  Exception_BusError, Exception_AddressError, Exception_Illegal, Exception_DivByZero
  dc.l  Exception_Chk, Exception_TrapV, Exception_PrivilegeViolation, Exception_Trace
  dc.l  Exception_LineA, Exception_LineF, Exception_Reserved, Exception_Reserved
  dc.l  Exception_Reserved

  ; uninitialized interrupt
  dc.l  Exception_Other

  ; reserved
  rept 8
  dc.l  Exception_Reserved
  endr

  ; interrupts
  dc.l  IRQ_Spurious, IRQ_Lvl1, IRQ_Lvl2, IRQ_Lvl3
  dc.l  IRQ_Lvl4, IRQ_Lvl5, IRQ_Lvl6, IRQ_Lvl7

  ; traps
  dc.l  Trap_EnterMonitor
  rept 15
  dc.l  Exception_UnimplementedTrap
  endr

  ; reserved
  rept 16
  dc.l  Exception_Reserved
  endr

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Exception handlers
;
; Any abnormal conditions (e.g. fatal exceptions) are handled by putting the
; exception reason in d0 and calling Exception_Handle.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Exception_BusError:
  move.b  #$01, d0
  bra.w   Exception_Handle

Exception_AddressError:
  move.b  #$02, d0
  bra.w   Exception_Handle

Exception_Illegal:
  move.b  #$03, d0
  bra.w   Exception_Handle

Exception_DivByZero:
  move.b  #$04, d0
  bra.w   Exception_Handle

Exception_Chk:
  move.b  #$05, d0
  bra.w   Exception_Handle

Exception_TrapV:
  move.b  #$06, d0
  bra.w   Exception_Handle

Exception_PrivilegeViolation:
  move.b  #$07, d0
  bra.w   Exception_Handle

Exception_Trace:
  move.b  #$08, d0
  bra.w   Exception_Handle

Exception_LineA:
  move.b  #$09, d0
  bra.w   Exception_Handle

Exception_LineF:
  move.b  #$0A, d0
  bra.w   Exception_Handle

Exception_Other:
  move.b  #$0B, d0
  bra.w   Exception_Handle

Exception_Reserved:
  move.b  #$0C, d0
  bra.w   Exception_Handle



; this does nothing rn
Exception_Handle:
  ; disable all interrupts
  move  $2700, sr

  ; set both status LEDs on
  movem.l d0/a0, -(sp)
  or.b    #%10001000, (Loader_68681Out)
  bsr.w   MC68681_UpdateOutput
  movem.l (sp)+, d0/a0

.Loop:
  ; wait lol
  nop
  bra.s .Loop

; enter the monitor from a trap
Trap_EnterMonitor:
  nop
  bra.s Trap_EnterMonitor

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; IRQ handlers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IRQ_Spurious:
  move.b  #$0D, d0
  bra.w   Exception_Handle

IRQ_Lvl1:
  move.l  a0, -(sp)
  lea     (Loader_IRQ1), a0
  jsr     (a0)
  move.l  (sp)+, a0
  rte

IRQ_Lvl2:
  move.l  a0, -(sp)
  lea     (Loader_IRQ2), a0
  jsr     (a0)
  move.l  (sp)+, a0
  rte

IRQ_Lvl3:
  move.l  a0, -(sp)
  lea     (Loader_IRQ3), a0
  jsr     (a0)
  move.l  (sp)+, a0
  rte

IRQ_Lvl4:
  move.l  a0, -(sp)
  lea     (Loader_IRQ4), a0
  jsr     (a0)
  move.l  (sp)+, a0
  rte

IRQ_Lvl5:
  move.l  a0, -(sp)
  lea     (Loader_IRQ5), a0
  jsr     (a0)
  move.l  (sp)+, a0
  rte

IRQ_Lvl6:
  move.l  a0, -(sp)
  lea     (Loader_IRQ6), a0
  jsr     (a0)
  move.l  (sp)+, a0
  rte

IRQ_Lvl7:
  move.l  a0, -(sp)
  lea     (Loader_IRQ7), a0
  jsr     (a0)
  move.l  (sp)+, a0
  rte



IRQ_Unused:
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Trap handlers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Exception_UnimplementedTrap:
  ; move.b  #$0E, d0
  bra.w   Exception_Handle



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Loader entry point
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EntryPoint:
  ; disable all interrupts
  move    #$2700, sr

  ; is this a warm boot? if so, skip RAM clearing
  cmp.l   #$DEADBEEF, (RAM_BootFlag)
  beq.s   .warmBoot

.coldBoot:
  ; clear all RAM
  lea     (RAM_Base), a0
  move.l  #(RAM_Size/4)-1, d1

.clear:
  move.l  d0, (a0)+
  dbf     d1, .clear

  ; set 'memory has been cleared'/warm boot flag
  move.l  #$DEADBEEF, (RAM_BootFlag)

  bra.s   .continueBoot

  ; handle warm boot specific stuff
.warmBoot:
  ; set the 'reset reason' flag
  move.b  #$01, (RAM_Reset_Reason)

.continueBoot:
  ; initialize IRQ vectors
  move.l  #IRQ_Unused, d0

  move.l  d0, Loader_IRQ1
  move.l  d0, Loader_IRQ2
  move.l  d0, Loader_IRQ3
  move.l  d0, Loader_IRQ4
  move.l  d0, Loader_IRQ5
  move.l  d0, Loader_IRQ6
  move.l  d0, Loader_IRQ7

  ; set up hardware
  bsr.w   MC68681_Reset
  bsr.w   RTC_Reset

  ; enter loader menu
  bra.w   Menu_Entry

  ; TODO: do stuff here, lmfao
  nop
  bra.s   EntryPoint

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Given a base address, validate the app header at that location, and if valid,
; jump to it.
;
; a0: Start of app header
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Loader_RunApp:
  ; disable all interrupts
  move    #$2700, sr

  ; back up base of table
  move.l  a0, a2

  ; check for magic
  move.w  (a0)+, d0
  cmp.w   #420, d0
  bne.s   .InvalidMagic

  ; validate version: anything with the high byte equal to $01 is supported
  move.w  (a0)+, d0
  and.w   #$FF00, d0
  cmp.w   #$0100, d0
  bne.s   .InvalidVersion

  ; compute checksum
  move.l  (a0)+, a1
  add.l   a2, a1
  move.l  (a0)+, d1
  subq.l  #1, d1

  moveq   #0, d0
  moveq   #0, d2

.ChecksumLoop:
  ; move.b  (a1)+, d2
  ; add.l   d2, d0
  ; dbf     d1, .ChecksumLoop

  ; compare it against what's expected
  ; cmp.l   (a0)+, d0
  ; bne.s   .InvalidChecksum

  ; if we get here, the header is valid, so jump to the app
  move.l  (a0)+, d0
  move.l  (a0), sp
  jmp     (a2, d0.w)



.InvalidMagic:
  reset
  moveq   #-1, d0
  rts
.InvalidVersion:
  reset
  moveq   #-2, d0
  rts
.InvalidChecksum:
  reset
  moveq   #-3, d0
  rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Loader tick function, this should be called periodically at 50Hz.
;
; This routine is guaranteed to not clobber any registers. It can, however, use
; the stack to back up registers.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Loader_Handle_Tick:
  ; just increment timer
  addq.l  #1, (Loader_Tick)
  rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Components of the bootloader
  include "menu.68k"
  include "uart_loader.68k"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; library type routines
  include "lib.68k"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Hardware support
	include	"68681.68k"
  include "rtc.68k"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Loader services
  include "loader_svc.68k"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Metadata
Info_BuildDate:
  incbin  "builddate.txt"
  dc.b    0
  dc.b    "Kush Blunt", 0
  even

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bootloader API entry point
  include "loader_entry.68k"
