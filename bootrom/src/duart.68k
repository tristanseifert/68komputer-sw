;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Routines for interfacing with the XR68C681 DUART
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DUART_Base                      = $130001

; Vector number assigned for the DUART IRQ
DUART_ISR_Vector                = $F0

; WRITE: channel A mode register
DUART_W_MRnA              = $0*2
; WRITE: channel A clock select
DUART_W_CSRA              = $1*2
; READ: channel A status register
DUART_R_SRA               = $1*2
; WRITE: channel A command register
DUART_W_CRA               = $2*2
; READ: masked IRQ status
DUART_R_MISR              = $2*2
; WRITE: channel A TX holding register
DUART_W_THRA              = $3*2
; READ: channel A RX holding register
DUART_R_RHRA              = $3*2

; WRITE: AUX control register
DUART_W_ACR               = $4*2
; READ: Input port change register
DUART_R_ACR               = $4*2

; WRITE: IRQ mask register
DUART_W_IMR               = $5*2
; READ: IRQ status register
DUART_R_ISR               = $5*2

; WRITE: Counter/Timer upper byte
DUART_W_CTU               = $6*2
; READ: Counter/Timer upper byte
DUART_R_CTU               = DUART_W_CTU

; WRITE: Counter/Timer lower byte
DUART_W_CTL               = $7*2
; READ: Counter/Timer lower byte
DUART_R_CTL               = DUART_W_CTL

; WRITE: channel B mode register
DUART_W_MRnB              = $8*2
; WRITE: channel B clock select
DUART_W_CSRB              = $9*2
; READ: channel B status register
DUART_R_SRB               = $9*2
; WRITE: channel B command register
DUART_W_CRB               = $A*2
; WRITE: channel B TX holding register
DUART_W_THRB              = $B*2
; READ: channel B RX holding register
DUART_R_RHRB              = $B*2

; WRITE: IRQ vector register
DUART_W_IVR               = $C*2
; READ: IRQ vector register
DUART_R_IVR               = DUART_W_IVR


; WRITE: output port configuration
DUART_W_OPCR              = $D*2
; READ: input port
DUART_R_IP                = $D*2

; WRITE: set output port register bits
DUART_W_SOPBC             = $E*2
; READ: Start counter/timer
DUART_R_SCC               = $E*2

; WRITE: clear output port register bits
DUART_W_COPBC             = $F*2
; READ: stop counter/timer
DUART_R_STC               = $F*2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initializes the DUART. The applied configuration is as follows:
;
; - UART A: 8N1, 19200 baud, hardware flow control
; - UART B: 8n1, 115200 baud, no flow control
; - Timer: fires every 10ms
DUART_Init:
    ; copy registers
    lea         .ResetData(pc), a0
    lea         (DUART_Base), a1

    moveq       #0, d1

.next:
    ; load register number
    move.b      (a0)+, d0
    ; if register number is $FF, abort
    cmp.b       #$FF, d0
    beq.s       .done

    ; write register data
    move.b      (a0)+, d1
    move.b      d1, (a1, d0.w)

    ; do the next register
    bra.s       .next

.done:
    ; lastly, start the timer by reading from the appropriate address
    move.b      DUART_R_SCC(a1), d0

    rts

; a set of 2-byte tuples in the format of register, value; terminate by writing a register $FF
.ResetData:
    ; aux control: bit rate set 1, timer mode with CLK/1. no input change IRQ
    dc.b        DUART_W_ACR, %11100000

    ; configure timer with a value of 18432 ($4800), this gives us 100Hz
    dc.b        DUART_W_CTU, $48
    dc.b        DUART_W_CTL, $00

    ; port A: reset receiver, transmitter, error status, break change interrupt
    dc.b        DUART_W_CRA, %00100000
    dc.b        DUART_W_CRA, %00110000
    dc.b        DUART_W_CRA, %01000000
    dc.b        DUART_W_CRA, %01010000
    ; port A: RxRDY IRQ, no parity, character FIFO errors, normal operation, 8N1, hw flow
    dc.b        DUART_W_CRA, %00010000 ; reset MRn pointer
    ;dc.b       DUART_W_MRnA, %00010011
    ;dc.b       DUART_W_MRnA, %00000111
    dc.b        DUART_W_MRnA, %10010011
    dc.b        DUART_W_MRnA, %00110111
    ; port A: set 19200 baud, set active mode, enable TX and RX
    dc.b        DUART_W_CRA, %10010000 ; clear RX BRG bit (X = 0)
    dc.b        DUART_W_CRA, %10110000 ; clear TX BRG bit (X = 0)
    dc.b        DUART_W_CSRA, %11001100 ; set 19.2k baud
    dc.b        DUART_W_CRA, %11010000
    dc.b        DUART_W_CRA, %00000101


    ; port B: reset receiver, transmitter, error status, break change interrupt
    dc.b        DUART_W_CRB, %00100000
    dc.b        DUART_W_CRB, %00110000
    dc.b        DUART_W_CRB, %01000000
    dc.b        DUART_W_CRB, %01010000
    ; port B: RxRDY IRQ, no parity, character FIFO errors, normal operation, 8N1
    dc.b        DUART_W_CRB, %00010000 ; reset MRn pointer
    dc.b        DUART_W_MRnB, %00010011
    dc.b        DUART_W_MRnB, %00000111
    ; port B: set 14,400 baud, set active mode, enable TX and RX
    dc.b        DUART_W_CRB, %10000000 ; set RX BRG bit (X = 1)
    dc.b        DUART_W_CRB, %10100000 ; set TX BRG bit (X = 1)
    ;dc.b    DUART_W_CSRB, %01010101 ; select 14.4k baud
    dc.b        DUART_W_CSRB, %10001000 ; select 115.2k baud
    dc.b        DUART_W_CRB, %11010000 ; set active mode
    dc.b        DUART_W_CRB, %00000101 ; enable tx/rx

    ; configure output port; clear all LEDs except for LED 4
    dc.b        DUART_W_OPCR, %00000000

    dc.b        DUART_W_COPBC, %11111100
    dc.b        DUART_W_SOPBC, %00000100

    ; desired irq vector
    dc.b        DUART_W_IVR, DUART_ISR_Vector
    ; enabled interrupts: counter ready
    dc.b        DUART_W_IMR, %00001000

    ; done
    dc.b        $FF, 0
    even

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Disables the UART receivers.
DUART_DisableRx:
    lea     DUART_Base, a0

    ; reset, then enable receiver for A
    move.b  #%00000010, DUART_W_CRA(a0)

    ; disable receivers for B
    move.b  #%00000010, DUART_W_CRB(a0)

    rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Enables the UART receivers.
DUART_EnableRx:
    lea     DUART_Base, a0

    ; reset, then enable receiver for A
    move.b  #%00100000, DUART_W_CRA(a0)
    move.b  #%00000001, DUART_W_CRA(a0)

    ; reset, then enable receivers for B
    move.b  #%00100000, DUART_W_CRB(a0)
    move.b  #%00000001, DUART_W_CRB(a0)

    rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ISR for the DUART (installed as vector $F0)
;
; The boot ROM only uses the ISR to update the time count value based on the tick timer in the
; DUART.
DUART_ISR:
    movem.l     d0/a0, -(sp)

    lea         (DUART_Base), a0
    move.b      DUART_R_ISR(a0), d0

    ; handle timer elapsed, reset the timer
    btst        #3, d0
    beq.s       .noTimer

    move.b      DUART_R_STC(a0), d0
    move.b      DUART_R_SCC(a0), d0

    addq.l      #1, (Current_Ticks).w

.noTimer:
    movem.l     (sp)+, d0/a0
    rte

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Transmits the given byte of data on UART A or B.
;
; INPUTS:
;   d0: Character to send
;
; CLOBBERS:
;   None
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DUART_Putch_A:
    ; read the status register, check TXRDY bit (2), loop while clear
    btst    #2, (DUART_Base+DUART_R_SRA)
    beq     DUART_Putch_A

    ; write character to DUART
    move.b  d0, (DUART_Base+DUART_W_THRA)
    rts

DUART_Putch_B:
    ; read the status register, check TXRDY bit (2), loop while clear
    btst    #2, (DUART_Base+DUART_R_SRB)
    beq     DUART_Putch_B

    ; write character to DUART
    move.b  d0, (DUART_Base+DUART_W_THRB)
    rts

